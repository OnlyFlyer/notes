

1. 执行栈与事件队列

JavaScript代码执行时, 会将不同的变量存于内存中不同的位置: 堆(heap)栈(stack), 堆里放一些对象, 栈中存放一些基础类型的变量以及对象的指针, 但这并不是指执行栈.

当我们调用一个方法的时候, JavaScript 会生成与这个方法对应的执行环境(context), 也就是执行上下文, 这个执行环境存在这个方法的私有作用域、上层作用域的指向、方法的参数, 定义的变量和this对象, 当一系列方法被一次调用的时候, 因为js是单线程的, 同一时间只能执行一个方法, 于是这些方法被排队在一个单独的地方, 就是执行栈.

当一个脚本第一次执行的时候, js 引擎先解析代码, 并将其中的同步代码按照执行顺序加入执行栈中, 从头开始执行, 若当前执行的是一个方法, 那么 js 会向执行栈中添加这个方法的执行环境, 并进入执行环境执行其中的代码, 执行完并返回结果后, js 会退出这个执行环境并销毁, 继续往下执行, 知道执行栈中的代码全部执行完毕.

上面的过程说的是同步代码的执行, 当异步代码(ajax请求数据)执行后就要用到事件队列这一概念(Task Queue).

js引擎遇到异步事件不会一直等待返回结果, 而是将事件挂起, 继续执行执行栈中下一个任务, 当异步时间返回结果后, js将这个事件加入与当前执行栈不同的另一个队列, 称之为事件队列, 放在事件队列不会马上执行回调, 会等待执行栈中所有任务都执行完毕, 主线程闲置的时候, 会去查找事件队列是否为空, 如果不为空, 那么会从取出排在第一位的事件, 并将它的回调放入执行栈, 然后执行其中的代码, 若还有异步代码, 则又将其挂起, 查找事件队列, 取出现在排在第一位的事件, 放入执行栈执行, 如此反复, 就形成了一个事件循环.


上面的事件循环的过程是一个宏观的表述, 实际上, 因为异步任务之间并不相同, 因此他们的执行有限级也不同, 分为: 微任务(micro task) 和 宏任务(macro task).

以下事件属于宏任务:
  - setInterval()
  - setTimeout()

以下事件属于微任务:
  - new Promise()
  - new MutaionObserver()

上面说过, 异步事件返回结果会被放到一个任务队列中, 但是根据这个异步事件的类型, 实际上会被放到相应的宏任务队列或微任务队列, 并且当前执行栈为空时, 主线程会先查看微任务队列是否有事件存在, 若不存在, 再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈, 若存在, 则依次将微任务队列中的事件回调放入执行栈中执行, 直到微任务队列为空, 再去宏任务队列执行相应的操作.

**当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出事件, 同一次事件循环中, 微任务永远在宏任务之前执行**

```JavaScript
  setTimeout(() => {
    console.log(1)
  })

  new Promise((resolve, reject) => {
    console.log(2)
    resolve(3)
  }).then((val) => {
    console.log(val)
  })

  // 结果: 2, 3, 1

```

2. xxx
3. yyy
4. zzz
